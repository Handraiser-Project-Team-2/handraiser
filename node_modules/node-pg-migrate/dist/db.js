"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const db = (connection, log = console.error) => {
    const isExternalClient = connection instanceof pg_1.Client;
    let clientActive = false;
    const client = isExternalClient ? connection : new pg_1.Client(connection);
    const beforeCloseListeners = [];
    const createConnection = () => new Promise((resolve, reject) => clientActive || isExternalClient
        ? resolve()
        : client.connect(err => {
            if (err) {
                log('could not connect to postgres', err);
                return reject(err);
            }
            clientActive = true;
            return resolve();
        }));
    const query = async (queryTextOrConfig, values) => {
        await createConnection();
        try {
            return await client.query(queryTextOrConfig, values);
        }
        catch (err) {
            const { message, position } = err;
            const string = typeof queryTextOrConfig === 'string' ? queryTextOrConfig : queryTextOrConfig.text;
            if (message && position >= 1) {
                const endLineWrapIndexOf = string.indexOf('\n', position);
                const endLineWrapPos = endLineWrapIndexOf >= 0 ? endLineWrapIndexOf : string.length;
                const stringStart = string.substring(0, endLineWrapPos);
                const stringEnd = string.substr(endLineWrapPos);
                const startLineWrapPos = stringStart.lastIndexOf('\n') + 1;
                const padding = ' '.repeat(position - startLineWrapPos - 1);
                log(`Error executing:
${stringStart}
${padding}^^^^${stringEnd}

${message}
`);
            }
            else {
                log(`Error executing:
${string}
${err}
`);
            }
            throw err;
        }
    };
    const select = async (queryTextOrConfig, values) => {
        const { rows } = await query(queryTextOrConfig, values);
        return rows;
    };
    const column = async (columnName, queryTextOrConfig, values) => {
        const rows = await select(queryTextOrConfig, values);
        return rows.map((r) => r[columnName]);
    };
    return {
        createConnection,
        query,
        select,
        column,
        addBeforeCloseListener: listener => beforeCloseListeners.push(listener),
        close: async () => {
            await beforeCloseListeners.reduce((promise, listener) => promise.then(listener).catch((err) => log(err.stack || err)), Promise.resolve());
            if (!isExternalClient) {
                clientActive = false;
                client.end();
            }
        },
    };
};
exports.default = db;
