"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decamelize_1 = __importDefault(require("decamelize"));
const PgLiteral_1 = __importDefault(require("./operations/PgLiteral"));
const identity = (v) => v;
const quote = (str) => `"${str}"`;
exports.createSchemalize = (shouldDecamelize, shouldQuote) => {
    const transform = [shouldDecamelize ? decamelize_1.default : identity, shouldQuote ? quote : identity].reduce((acc, fn) => fn === identity ? acc : (x) => acc(fn(x)));
    return (v) => {
        if (typeof v === 'object') {
            const { schema, name } = v;
            return (schema ? `${transform(schema)}.` : '') + transform(name);
        }
        return transform(v);
    };
};
exports.createTransformer = (literal) => (s, d) => Object.keys(d || {}).reduce((str, p) => str.replace(new RegExp(`{${p}}`, 'g'), d === undefined || d[p] === undefined ? '' : literal(d[p])), s);
exports.escapeValue = (val) => {
    if (val === null) {
        return 'NULL';
    }
    if (typeof val === 'boolean') {
        return val.toString();
    }
    if (typeof val === 'string') {
        let dollars;
        let index = 0;
        do {
            index += 1;
            dollars = `$pg${index}$`;
        } while (val.indexOf(dollars) >= 0);
        return `${dollars}${val}${dollars}`;
    }
    if (typeof val === 'number') {
        return val;
    }
    if (Array.isArray(val)) {
        const arrayStr = val
            .map(exports.escapeValue)
            .join(',')
            .replace(/ARRAY/g, '');
        return `ARRAY[${arrayStr}]`;
    }
    if (val instanceof PgLiteral_1.default) {
        return val.toString();
    }
    return '';
};
exports.getSchemas = (schema) => {
    const schemas = (Array.isArray(schema) ? schema : [schema]).filter((s) => typeof s === 'string' && s.length > 0);
    return schemas.length > 0 ? schemas : ['public'];
};
exports.getMigrationTableSchema = (options) => options.migrationsSchema !== undefined ? options.migrationsSchema : exports.getSchemas(options.schema)[0];
const typeAdapters = {
    int: 'integer',
    string: 'text',
    float: 'real',
    double: 'double precision',
    datetime: 'timestamp',
    bool: 'boolean',
};
const defaultTypeShorthands = {
    id: { type: 'serial', primaryKey: true },
};
exports.applyTypeAdapters = (type) => type in typeAdapters ? typeAdapters[type] : type;
exports.applyType = (type, extendingTypeShorthands = {}) => {
    const typeShorthands = Object.assign(Object.assign({}, defaultTypeShorthands), extendingTypeShorthands);
    const options = typeof type === 'string' ? { type } : type;
    let ext = null;
    const types = [options.type];
    while (typeShorthands[types[types.length - 1]]) {
        if (ext) {
            delete ext.type;
        }
        const t = typeShorthands[types[types.length - 1]];
        ext = Object.assign(Object.assign({}, (typeof t === 'string' ? { type: t } : t)), (ext === null ? {} : ext));
        if (types.includes(ext.type)) {
            throw new Error(`Shorthands contain cyclic dependency: ${types.join(', ')}, ${ext.type}`);
        }
        else {
            types.push(ext.type);
        }
    }
    if (!ext) {
        ext = { type: options.type };
    }
    return Object.assign(Object.assign(Object.assign({}, ext), options), { type: exports.applyTypeAdapters(ext.type) });
};
const formatParam = (mOptions) => (param) => {
    const { mode, name, type, default: defaultValue } = exports.applyType(param, mOptions.typeShorthands);
    const options = [];
    if (mode) {
        options.push(mode);
    }
    if (name) {
        options.push(mOptions.literal(name));
    }
    if (type) {
        options.push(type);
    }
    if (defaultValue) {
        options.push(`DEFAULT ${exports.escapeValue(defaultValue)}`);
    }
    return options.join(' ');
};
exports.formatParams = (params = [], mOptions) => `(${params.map(formatParam(mOptions)).join(', ')})`;
exports.makeComment = (object, name, text) => {
    const cmt = exports.escapeValue(text || null);
    return `COMMENT ON ${object} ${name} IS ${cmt};`;
};
exports.formatLines = (lines, replace = '  ', separator = ',') => lines
    .map(line => line.replace(/(?:\r\n|\r|\n)+/g, ' '))
    .join(`${separator}\n`)
    .replace(/^/gm, replace);
