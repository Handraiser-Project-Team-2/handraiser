"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
function generateIndexName(table, columns, options) {
    if (options.name) {
        return typeof table === 'object' ? { schema: table.schema, name: options.name } : options.name;
    }
    const cols = lodash_1.default.isArray(columns) ? columns.join('_') : columns;
    const uniq = 'unique' in options && options.unique ? '_unique' : '';
    return typeof table === 'object'
        ? {
            schema: table.schema,
            name: `${table.name}_${cols}${uniq}_index`,
        }
        : `${table}_${cols}${uniq}_index`;
}
function generateColumnString(column, literal) {
    const openingBracketPos = column.indexOf('(');
    const closingBracketPos = column.indexOf(')');
    const isFunction = openingBracketPos >= 0 && closingBracketPos > openingBracketPos;
    return isFunction
        ? column
        : literal(column);
}
function generateColumnsString(columns, literal) {
    return lodash_1.default.isArray(columns)
        ? columns.map(column => generateColumnString(column, literal)).join(', ')
        : generateColumnString(columns, literal);
}
function dropIndex(mOptions) {
    const _drop = (tableName, columns, options = {}) => {
        const { concurrently, ifExists, cascade } = options;
        const concurrentlyStr = concurrently ? ' CONCURRENTLY' : '';
        const ifExistsStr = ifExists ? ' IF EXISTS' : '';
        const indexName = generateIndexName(tableName, columns, options);
        const cascadeStr = cascade ? ' CASCADE' : '';
        const indexNameStr = mOptions.literal(indexName);
        return `DROP INDEX${concurrentlyStr}${ifExistsStr} ${indexNameStr}${cascadeStr};`;
    };
    return _drop;
}
exports.dropIndex = dropIndex;
function createIndex(mOptions) {
    const _create = (tableName, columns, options = {}) => {
        const indexName = generateIndexName(typeof tableName === 'object' ? tableName.name : tableName, columns, options);
        const columnsString = generateColumnsString(columns, mOptions.literal);
        const unique = options.unique ? ' UNIQUE' : '';
        const concurrently = options.concurrently ? ' CONCURRENTLY' : '';
        const ifNotExistsStr = options.ifNotExists ? ' IF NOT EXISTS' : '';
        const method = options.method ? ` USING ${options.method}` : '';
        const where = options.where ? ` WHERE ${options.where}` : '';
        const opclass = options.opclass ? ` ${mOptions.schemalize(options.opclass)}` : '';
        const include = options.include
            ? ` INCLUDE (${(lodash_1.default.isArray(options.include) ? options.include : [options.include])
                .map(mOptions.literal)
                .join(', ')})`
            : '';
        const indexNameStr = mOptions.literal(indexName);
        const tableNameStr = mOptions.literal(tableName);
        return `CREATE${unique} INDEX${concurrently}${ifNotExistsStr} ${indexNameStr} ON ${tableNameStr}${method} (${columnsString}${opclass})${include}${where};`;
    };
    _create.reverse = dropIndex(mOptions);
    return _create;
}
exports.createIndex = createIndex;
