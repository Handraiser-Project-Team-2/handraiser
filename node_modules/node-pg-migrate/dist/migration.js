"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const migration_builder_1 = __importDefault(require("./migration-builder"));
const utils_1 = require("./utils");
const readdir = util_1.promisify(fs_1.default.readdir);
const lstat = util_1.promisify(fs_1.default.lstat);
const SEPARATOR = '_';
exports.loadMigrationFiles = async (dir, ignorePattern) => {
    const dirContent = await readdir(`${dir}/`);
    const files = (await Promise.all(dirContent.map(async (file) => {
        const stats = await lstat(`${dir}/${file}`);
        return stats.isFile() ? file : null;
    })))
        .filter((file) => Boolean(file))
        .sort();
    const filter = new RegExp(`^(${ignorePattern})$`);
    return ignorePattern === undefined ? files : files.filter(i => !filter.test(i));
};
const getLastSuffix = async (dir, ignorePattern) => {
    try {
        const files = await exports.loadMigrationFiles(dir, ignorePattern);
        return files.length > 0 ? path_1.default.extname(files[files.length - 1]).substr(1) : undefined;
    }
    catch (err) {
        return undefined;
    }
};
class Migration {
    constructor(db, migrationPath, { up, down }, options, typeShorthands, log = console.log) {
        this.db = db;
        this.path = migrationPath;
        this.name = path_1.default.basename(migrationPath, path_1.default.extname(migrationPath));
        this.timestamp = Number(this.name.split(SEPARATOR)[0]) || 0;
        this.up = up;
        this.down = down;
        this.options = options;
        this.typeShorthands = typeShorthands;
        this.log = log;
    }
    static async create(name, directory, language, ignorePattern) {
        mkdirp_1.default.sync(directory);
        const suffix = language || (await getLastSuffix(directory, ignorePattern)) || 'js';
        const newFile = `${directory}/${Date.now()}${SEPARATOR}${name}.${suffix}`;
        await new Promise(resolve => {
            fs_1.default.createReadStream(path_1.default.resolve(__dirname, `../templates/migration-template.${suffix}`))
                .pipe(fs_1.default.createWriteStream(newFile))
                .on('end', resolve);
        });
        return newFile;
    }
    _getMarkAsRun(action) {
        const schema = utils_1.getMigrationTableSchema(this.options);
        const { migrationsTable } = this.options;
        const { name } = this;
        switch (action) {
            case this.down:
                this.log(`### MIGRATION ${this.name} (DOWN) ###`);
                return `DELETE FROM "${schema}"."${migrationsTable}" WHERE name='${name}';`;
            case this.up:
                this.log(`### MIGRATION ${this.name} (UP) ###`);
                return `INSERT INTO "${schema}"."${migrationsTable}" (name, run_on) VALUES ('${name}', NOW());`;
            default:
                throw new Error('Unknown direction');
        }
    }
    async _apply(action, pgm) {
        if (action.length === 2) {
            await new Promise(resolve => action(pgm, resolve));
        }
        else {
            await action(pgm);
        }
        const sqlSteps = pgm.getSqlSteps();
        sqlSteps.push(this._getMarkAsRun(action));
        if (!this.options.singleTransaction && pgm.isUsingTransaction()) {
            sqlSteps.unshift('BEGIN;');
            sqlSteps.push('COMMIT;');
        }
        else if (this.options.singleTransaction && !pgm.isUsingTransaction()) {
            this.log('#> WARNING: Need to break single transaction! <');
            sqlSteps.unshift('COMMIT;');
            sqlSteps.push('BEGIN;');
        }
        else if (!this.options.singleTransaction || !pgm.isUsingTransaction()) {
            this.log('#> WARNING: This migration is not wrapped in a transaction! <');
        }
        this.log(`${sqlSteps.join('\n')}\n\n`);
        return sqlSteps.reduce((promise, sql) => promise.then(() => this.options.dryRun || this.db.query(sql)), Promise.resolve());
    }
    _getAction(direction) {
        if (direction === 'down' && this.down === undefined) {
            this.down = this.up;
        }
        const action = this[direction];
        if (action === false) {
            throw new Error(`User has disabled ${direction} migration on file: ${this.name}`);
        }
        if (typeof action !== 'function') {
            throw new Error(`Unknown value for direction: ${direction}. Is the migration ${this.name} exporting a '${direction}' function?`);
        }
        return action;
    }
    apply(direction) {
        const pgm = new migration_builder_1.default(this.db, this.typeShorthands, Boolean(this.options.decamelize));
        const action = this._getAction(direction);
        if (this.down === this.up) {
            pgm.enableReverseMode();
        }
        return this._apply(action, pgm);
    }
    markAsRun(direction) {
        return this.db.query(this._getMarkAsRun(this._getAction(direction)));
    }
}
exports.Migration = Migration;
